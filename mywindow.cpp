// We include the header file of MyWindow class - main widget (window) of our application
#include "mywindow.h"

#include <stdlib.h>     //abs()
#include <iostream>

// Include the header file containing definitions GUI
// This file is automatically generated when you build the project
// It is based on data from an XML file "mywindow.ui"
#include "ui_mywindow.h"

// The definition of the constructor of MyWindow class
// First call the constructor of the parent class,
// next create object representing the GUI
MyWindow::MyWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MyWindow)
{
    // Function creating GUI elements (defined in "ui_mywindow.h")
    ui->setupUi(this);

    // Get the dimensions and coordinates of the top left corner of the frame
    // and set the corresponding parameters of the image
    // Note: we use 'drawFrame' only for handy setting these values,
    // the image will be displayed directly on the main application window.
    img_width = ui->drawFrame->width();
    img_height = ui->drawFrame->height();
    img_x0 = ui->drawFrame->x();
    img_y0 = ui->drawFrame->y();

    // Create an object of QImage class of appropriate width
    // and height. Set its format for 32-bit RGB (0xffRRGGBB).
    img = new QImage(img_width,img_height,QImage::Format_RGB32);

}

// Definition of destructor
MyWindow::~MyWindow()
{
    delete ui;
}

// Function (slot) called when user push the button 'Quit' (ExitButton)
// Note: The connection of this function with the signal "clicked"
// emitted by the button is created by using the built QMetaObject :: connectSlotsByName (MyWindow)
// located in the automatically generated file "ui_mywindow.h"
// so we do not need create connection manually using 'connect' function.
void MyWindow::on_exitButton_clicked()
{
    // qApp is a global pointer referring to the unique application object,
    // in GUI applications, it is a pointer to a QApplication instance.
    // quit() is a function telling the application to exit with return code 0 (success).
    qApp->quit();
}


// A paint event is a request to repaint all or part of a widget. It can happen for one of the following reasons:
// repaint() or update() was invoked, the widget was obscured and has now been uncovered, or many other reasons.
void MyWindow::paintEvent(QPaintEvent*)
{

    // The QPainter class performs low-level painting on widgets and other paint devices.
    QPainter p(this);

    // Draws an image 'img' by copying it into the paint device.
    // (img_x0, img_y0) specifies the top-left point in the paint device that is to be drawn onto.
    p.drawImage(img_x0,img_y0,*img);
}


// Function (slot) called when the user clicks button "Clean" (cleanButton)
void MyWindow::on_cleanButton_clicked()
{
    // Function 'img_clean()' cleans the image (create all white image)
    // definition is provided below
    img_clean();

    // Invoke the 'paintEvent' and repaint the entire widget
    update();
}

// Function cleaning the image (painting it in all white)
void MyWindow::img_clean()
{
    unsigned char *ptr;

    // 'bits()' returns a pointer to the first pixel of the image
    ptr = img->bits();

    int i,j;

    // i - current row, it changes from 0 to img_height-1
    for(i=0; i<img_height; i++)
    {
        // j - current column, it changes from 0 to img_width
        // each row has img_width pixels and 4 * img_width bytes (1 pixel = 4 bytes)
        for(j=0; j<img_width; j++)
        {
            // to obtain a white color we set each component on max value (255)
            ptr[img_width*4*i + 4*j]=255; // BLUE component
            ptr[img_width*4*i + 4*j + 1] = 255; // GREEN component
            ptr[img_width*4*i + 4*j + 2] = 255; // RED component
        }
    }
}

void MyWindow::pix(int x, int y)
{
    unsigned char* ptr = img->bits();

    ptr[img_width * 4 * y + 4 * x]= 0;
    ptr[img_width * 4 * y + 4 * x + 1] = 0;
    ptr[img_width * 4 * y + 4 * x + 2] = 0;
}

// Function (slot) called when the user press mouse button
void MyWindow::mousePressEvent(QMouseEvent *event) {
    // Get coordinates of the mouse cursor
    this->section_x1 = event->x();
    this->section_y1 = event->y();

    // x and y are coordinates relative to the application window
    // we subtract coordinates of the upper left corner of the image
    // to obtain coordinates relative to the image
    this->section_x1 -= img_x0;
    this->section_y1 -= img_y0;

    unsigned char *ptr;
    ptr = img->bits();

    // Checking if mouse cursor is in the image border
    if ((this->section_x1 >= 0) && (this->section_y1 >= 0) &&
            (this->section_x1 < img_width) && (this->section_y1 < img_height)) {
        ptr[img_width * 4 * this->section_y1 + 4 * this->section_x1] = 255;
        ptr[img_width * 4 * this->section_y1 + 4 * this->section_x1 + 1] = 125;
        ptr[img_width * 4 * this->section_y1 + 4 * this->section_x1 + 2] = 125;
    }

    // We refresh the image
    update();
}

void MyWindow::mouseReleaseEvent(QMouseEvent *event) {
    // Get coordinates of the mouse cursor
    this->section_x2 = event->x();
    this->section_y2 = event->y();

    // x and y are coordinates relative to the application window
    // we subtract coordinates of the upper left corner of the image
    // to obtain coordinates relative to the image
    this->section_x2 -= img_x0;
    this->section_y2 -= img_y0;

    double a = 1.0 * (this->section_y2 - this->section_y1) / (this->section_x2 - this->section_x1);
    double b = this->section_y1 - a * this->section_x1;
    // Tangens
    double tg = abs((this->section_y1 - this->section_y2) / (this->section_x1 - this->section_x2));

    // Checking if mouse cursor is in the image border
    if ((this->section_x2 >= 0) && (this->section_y2 >= 0) &&
            (this->section_x2 < img_width) && (this->section_y2 < img_height)) {
        if(tg < 1) {
            int y;
            // From left to right
            if(this->section_x1 < this->section_x2) {
                for(int x = this->section_x1; x < this->section_x2; x++) {
                    y = (int)floor(a * x + b + 0.5);
                    pix(x, y);
                }

            // From right to left
            } else {
                for(int x = this->section_x2; x < this->section_x1; x++) {
                    y = (int)floor(a * x + b + 0.5);
                    pix(x, y);
                }
            }
        } else {
            int x;
            // From up to down
            if(this->section_y1 < this->section_y2) {
                for(int y = this->section_y1; y < this->section_y2; y++) {
                    x = (int)floor(1/a * y - b/a + 0.5);
                    pix(x, y);
                }
            // From down to up
            } else {
                for(int y = this->section_y2; y < this->section_y1; y++) {
                    int x = (int)floor(1/a * y - b/a + 0.5);
                    pix(x, y);
                }
            }
        }
    }

    // We refresh the image
    update();
}


